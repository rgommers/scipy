from __future__ import annotations

from typing import (
    Callable,
    overload,
    Literal,
)

from numpy.typing import ArrayLike

from scipy._lib._util import DecimalNumber, IntNumber

_ComplexNumber = DecimalNumber | complex

_PointsDerivate = tuple[ArrayLike, ArrayLike]
_ZerosOrder = tuple[ArrayLike, ArrayLike, ArrayLike, ArrayLike]

__all__ = [
    "ai_zeros",
    "assoc_laguerre",
    "bei_zeros",
    "beip_zeros",
    "ber_zeros",
    "bernoulli",
    "berp_zeros",
    "bi_zeros",
    "clpmn",
    "comb",
    "diric",
    "erf_zeros",
    "euler",
    "factorial",
    "factorial2",
    "factorialk",
    "fresnel_zeros",
    "fresnelc_zeros",
    "fresnels_zeros",
    "h1vp",
    "h2vp",
    "ivp",
    "jn_zeros",
    "jnjnp_zeros",
    "jnp_zeros",
    "jnyn_zeros",
    "jvp",
    "kei_zeros",
    "keip_zeros",
    "kelvin_zeros",
    "ker_zeros",
    "kerp_zeros",
    "kvp",
    "lmbda",
    "lpmn",
    "lpn",
    "lqmn",
    "lqn",
    "mathieu_even_coef",
    "mathieu_odd_coef",
    "obl_cv_seq",
    "pbdn_seq",
    "pbdv_seq",
    "pbvv_seq",
    "perm",
    "polygamma",
    "pro_cv_seq",
    "riccati_jn",
    "riccati_yn",
    "stirling2",
    "y0_zeros",
    "y1_zeros",
    "y1p_zeros",
    "yn_zeros",
    "ynp_zeros",
    "yvp",
    "zeta",
]

def diric(x: ArrayLike, n: DecimalNumber) -> ArrayLike: ...
def jnjnp_zeros(nt: int) -> _ZerosOrder: ...
def jnyn_zeros(n: int, nt: int) -> _ZerosOrder: ...
def jn_zeros(n: int, nt: int) -> ArrayLike: ...
def jnp_zeros(n: int, nt: int) -> ArrayLike: ...
def yn_zeros(n: int, nt: int) -> ArrayLike: ...
def ynp_zeros(n: int, nt: int) -> ArrayLike: ...
def y0_zeros(nt: int, complex: bool = ...) -> _PointsDerivate: ...
def y1_zeros(nt: int, complex: bool = ...) -> _PointsDerivate: ...
def y1p_zeros(nt: int, complex: bool = ...) -> _PointsDerivate: ...
@overload
def jvp(
    v: ArrayLike, z: DecimalNumber | ArrayLike, n: int = ...
) -> ArrayLike: ...
@overload
def jvp(
    v: DecimalNumber | ArrayLike, z: ArrayLike, n: int = ...
) -> ArrayLike: ...
@overload
def jvp(
    v: DecimalNumber, z: DecimalNumber, n: int = ...
) -> DecimalNumber: ...
@overload
def yvp(
    v: ArrayLike, z: DecimalNumber | ArrayLike, n: int = ...
) -> ArrayLike: ...
@overload
def yvp(
    v: DecimalNumber | ArrayLike, z: ArrayLike, n: int = ...
) -> ArrayLike: ...
@overload
def yvp(
    v: DecimalNumber, z: DecimalNumber, n: int = ...
) -> DecimalNumber: ...
@overload
def kvp(v: DecimalNumber, z: _ComplexNumber, n: int = 1) -> DecimalNumber: ...
@overload
def kvp(
    v: ArrayLike, z: ArrayLike | _ComplexNumber, n: int = 1
) -> ArrayLike: ...
@overload
def kvp(
    v: ArrayLike | DecimalNumber, z: ArrayLike, n: int = 1
) -> ArrayLike: ...
@overload
def ivp(
    v: ArrayLike, z: DecimalNumber | ArrayLike, n: int = ...
) -> ArrayLike: ...
@overload
def ivp(
    v: DecimalNumber | ArrayLike, z: ArrayLike, n: int = ...
) -> ArrayLike: ...
@overload
def ivp(
    v: DecimalNumber, z: DecimalNumber, n: int = ...
) -> DecimalNumber: ...
@overload
def h1vp(
    v: ArrayLike, z: DecimalNumber | ArrayLike, n: int = ...
) -> ArrayLike: ...
@overload
def h1vp(
    v: DecimalNumber | ArrayLike, z: ArrayLike, n: int = ...
) -> ArrayLike: ...
@overload
def h1vp(
    v: DecimalNumber, z: DecimalNumber, n: int = ...
) -> DecimalNumber: ...
@overload
def h2vp(
    v: ArrayLike, z: DecimalNumber | ArrayLike, n: int = ...
) -> ArrayLike: ...
@overload
def h2vp(
    v: DecimalNumber | ArrayLike, z: ArrayLike, n: int = ...
) -> ArrayLike: ...
@overload
def h2vp(
    v: DecimalNumber, z: DecimalNumber, n: int = ...
) -> DecimalNumber: ...
def riccati_jn(n: int, x: float) -> _PointsDerivate: ...
def riccati_yn(n: int, x: float) -> _PointsDerivate: ...
def erf_zeros(nt: int) -> ArrayLike[_ComplexNumber]: ...
def fresnelc_zeros(nt: int) -> ArrayLike: ...
def fresnels_zeros(nt: int) -> ArrayLike: ...
def fresnel_zeros(nt: int) -> _PointsDerivate: ...
@overload
def assoc_laguerre(x: ArrayLike, n: int, k: float = ...) -> ArrayLike: ...
@overload
def assoc_laguerre(x: DecimalNumber, n: int, k: float = ...) -> DecimalNumber: ...
def polygamma(n: int, x: ArrayLike) -> ArrayLike: ...
def mathieu_even_coef(m: int, q: DecimalNumber) -> ArrayLike: ...
def mathieu_odd_coef(m: int, q: DecimalNumber) -> ArrayLike: ...
def lpmn(m: DecimalNumber, n: DecimalNumber, z: DecimalNumber) -> _PointsDerivate: ...
def clpmn(m: DecimalNumber, n: DecimalNumber, z: _ComplexNumber, type: Literal[2, 3] = ...) -> _PointsDerivate: ...
def lqmn(m: IntNumber, n: IntNumber, z: DecimalNumber) -> _PointsDerivate: ...
def bernoulli(n: int) -> ArrayLike: ...
def euler(n: int) -> ArrayLike: ...
def lpn(n: int, z: DecimalNumber) -> _PointsDerivate: ...
def lqn(n: int, z: DecimalNumber) -> _PointsDerivate: ...
def ai_zeros(nt: int) -> _ZerosOrder: ...
def bi_zeros(nt: int) -> _ZerosOrder: ...
def lmbda(v: int, x: int) -> _PointsDerivate: ...
def pbdv_seq(v: DecimalNumber, x: DecimalNumber) -> _PointsDerivate: ...
def pbvv_seq(v: DecimalNumber, x: DecimalNumber) -> _PointsDerivate: ...
def pbdn_seq(n: int, z: _ComplexNumber) -> _PointsDerivate: ...
def ber_zeros(nt: int) -> ArrayLike: ...
def bei_zeros(nt: int) -> ArrayLike: ...
def ker_zeros(nt: int) -> ArrayLike: ...
def kei_zeros(nt: int) -> ArrayLike: ...
def berp_zeros(nt: int) -> ArrayLike: ...
def beip_zeros(nt: int) -> ArrayLike: ...
def kerp_zeros(nt: int) -> ArrayLike: ...
def keip_zeros(nt: int) -> ArrayLike: ...
def kelvin_zeros(nt: int) -> tuple[ArrayLike, ArrayLike, ArrayLike, ArrayLike, ArrayLike, ArrayLike, ArrayLike, ArrayLike]: ...
def pro_cv_seq(m: IntNumber, n: IntNumber, c: DecimalNumber) -> ArrayLike: ...
def obl_cv_seq(m: IntNumber, n: IntNumber, c: DecimalNumber) -> ArrayLike: ...
@overload
def comb(
    N: ArrayLike,
    k: ArrayLike,
    *,
    exact: bool = ...,
    repetition: bool = ...,
    legacy: bool = ...,
) -> ArrayLike: ...
@overload
def comb(
    N: DecimalNumber,
    k: DecimalNumber,
    *,
    exact: bool = ...,
    repetition: bool = ...,
    legacy: bool = ...,
) -> DecimalNumber: ...
@overload
def perm(N: IntNumber, k: IntNumber, exact: bool = ...) -> IntNumber: ...
@overload
def perm(N: ArrayLike, k: ArrayLike, exact: bool = ...) -> ArrayLike: ...
@overload
def factorial(n: ArrayLike, exact: bool = ...) -> ArrayLike: ...
@overload
def factorial(n: DecimalNumber, exact: bool = ...) -> DecimalNumber: ...
@overload
def factorial2(n: ArrayLike, exact: bool = ...) -> ArrayLike: ...
@overload
def factorial2(n: IntNumber, exact: bool = ...) -> DecimalNumber: ...
@overload
def factorialk(n: IntNumber, k: int, exact: bool = ...) -> DecimalNumber: ...
@overload
def factorialk(n: ArrayLike, k: int, exact: bool = ...) -> ArrayLike: ...
def stirling2(N: ArrayLike, K: ArrayLike, *, exact: bool = ...) -> ArrayLike: ...
@overload
def zeta(
    x: DecimalNumber, q: DecimalNumber | None = ..., out: None = ...
) -> DecimalNumber: ...
@overload
def zeta(
    x: DecimalNumber, q: DecimalNumber | None = ..., out: None = ...
) -> DecimalNumber: ...
@overload
def zeta(
    x: ArrayLike, q: ArrayLike | DecimalNumber | None = ..., out: None = ...
) -> ArrayLike: ...
@overload
def zeta(
    x: ArrayLike, q: ArrayLike | DecimalNumber | None = ..., out: None = ...
) -> ArrayLike: ...
@overload
def zeta(
    x: ArrayLike | DecimalNumber, q: ArrayLike, out: None = ...
) -> ArrayLike: ...
@overload
def zeta(
    x: DecimalNumber | ArrayLike,
    q: ArrayLike | DecimalNumber | None,
    out: ArrayLike,
) -> None: ...

# Those are private methods
def _factorialx_approx_core(n: ArrayLike, k: int) -> ArrayLike: ...
def _factorialx_array_approx(n: ArrayLike, k: int) -> ArrayLike: ...
def _factorialx_array_exact(n: ArrayLike, k: int = ...) -> ArrayLike: ...
def _range_prod(lo: IntNumber, hi: IntNumber, k: IntNumber = 1) -> IntNumber: ...
def _nonneg_int_or_fail(n: IntNumber, var_name: str, strict: bool = ...) -> int: ...
@overload
def _bessel_diff_formula(
    v: ArrayLike,
    z: ArrayLike | DecimalNumber,
    n: int,
    L: Callable[[ArrayLike, DecimalNumber], ArrayLike],
    phase: int
) -> ArrayLike: ...
@overload
def _bessel_diff_formula(
    v: ArrayLike | DecimalNumber,
    z: ArrayLike,
    n: int,
    L: Callable[[ArrayLike, DecimalNumber], ArrayLike],
    phase: int
) -> ArrayLike: ...
@overload
def _bessel_diff_formula(
    v: DecimalNumber,
    z: DecimalNumber,
    n: int,
    L: Callable[[ArrayLike, DecimalNumber], ArrayLike],
    phase: int
) -> DecimalNumber: ...
